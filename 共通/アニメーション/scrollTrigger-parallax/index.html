<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>GSAP パララックス / sticky / abs 挙動サンプル</title>

    <!-- CSS（head内に記述する要求）-->
    <style>
      /* リセット */
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      html,
      body {
        height: 100%;
      }
      body {
        font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Yu Gothic',
          'Hiragino Kaku Gothic ProN', 'Noto Sans JP';
      }

      /* 全体コンテナ */
      .f-container {
        background-color: yellowgreen;
        min-height: 200vh;
      } /* デモ用に少し長めに確保 */

      .f-main {
        width: 50rem;
        margin: 0 auto;
        position: relative;
        overflow: visible;
      } /* movie-top.abs の absolute 基準 */

      /* movie-top（ビデオエリア） */
      .movie-top {
        width: 100%;
        height: 100vh; /* video は画面高さ分 */
        display: block;
        background: #000;
        /* デフォルトは static（位置は自然） */
        position: static;
        z-index: 5;
        will-change: transform;
      }
      .movie-top video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }

      /* sticky状態: top:0に固定 */
      .movie-top.sticky {
        /* position: fixed; */
        position: sticky;
        top: 0;
        z-index: 1;
        /* left: 0;
        right: 0; */
        /* z-index: 30; */
      }

      /* abs状態: .f-main を基準に下部に固定する */
      .movie-top.abs {
        position: absolute !important;
        top: auto;
        bottom: 0;
        left: 0;
        right: 0;
        /* z-index: 20; */
      }

      /* f-main-wrap: パララックスさせる要素 */
      .f-main-wrap {
        position: relative;
        z-index: 2;
        width: 100%;
        /* padding-bottom はスクリプトで video 高さ分を付与・除去します（パララックスによる隙間補正） */
        color: #fff;
        min-height: 150vh; /* デモで中身を長くするため */
        transition: padding-bottom 0.2s ease;
      }

      /* particles area（100vh の雪などを想定） */
      .particles-wrapper {
        position: absolute;
        /* 動画の高さ分 */
        top: 100vh;
        z-index: 15;
        background-color: aqua;
        width: 100%;
        height: 100vh;
        pointer-events: none;
        opacity: 0.3;
        transition: opacity 0.35s ease;
      }
      .particles-wrapper.on {
        opacity: 0.5;
        position: fixed;
        top: 0;
        left: 0;
      }

      .contents {
        position: relative;
        z-index: 10;
        background: beige;
        padding: 40px;
        font-size: 18px;
        line-height: 1.8;
        max-width: 900px;
        margin: 0 auto 200px;
      }

      /* last 要素（判定用） */
      .last {
        height: 60vh;
        background: linear-gradient(#f5f5f5, #ddd);
        border-top: 4px solid #ccc;
      }

      /* デバッグ用の視覚化（不要なら削除可） */
      .debug-box {
        position: fixed;
        right: 12px;
        bottom: 12px;
        background: rgba(0, 0, 0, 0.6);
        color: #fff;
        padding: 8px 10px;
        border-radius: 6px;
        font-size: 13px;
        z-index: 9999;
      }
    </style>

    <!-- GSAP + ScrollTrigger CDN（head内）-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>

    <!-- JS（head内に記述する要求）-->
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        gsap.registerPlugin(ScrollTrigger);

        const movieTop = document.querySelector('.movie-top');
        const fMain = document.querySelector('.f-main');
        const fMainWrap = document.querySelector('.f-main-wrap');
        const particles = document.querySelector('.particles-wrapper');
        const last = document.querySelector('.last');

        const videoEl = movieTop.querySelector('video');

        // ビデオ高さ（ピクセル）取得関数（レスポンシブ対応）
        function getVideoHeight() {
          // movieTop の高さを基準にする（CSSで100vhにしてあるためこれが安定）
          return Math.round(
            movieTop.getBoundingClientRect().height || window.innerHeight
          );
        }

        // パララックス（f-main-wrap を上へ移動するアニメーション）
        let parallaxTween = gsap.to(fMainWrap, {
          y: () => -getVideoHeight(),
          ease: 'none',
          paused: true,
          // ScrollTrigger を後でセット
        });

        // ScrollTrigger: movie の下端が viewport 下端に到達したときからビデオ高さ分スクロールする間にパララックスする
        let parallaxTrigger = ScrollTrigger.create({
          trigger: movieTop,
          start: 'bottom bottom', // movie-bottom が viewport-bottom に達した瞬間
          end: () => '+=' + getVideoHeight(), // その後ビデオ高さ分スクロールしたところまで
          scrub: true,
          onEnter: () => {
            // パララックスが始まるタイミング（必要なら何か）
          },
          onLeave: () => {
            // 終了時
          },
          // update tween progress manually to ensure precise control
          onUpdate: (self) => {
            const prog = self.progress; // 0 -> 1
            parallaxTween.progress(prog);
          },
        });

        // particles と movie-top sticky の切り替え
        // f-main-wrap の上端が viewport top に達した時に on をつける（top top）
        const stickyTrigger = ScrollTrigger.create({
          trigger: fMainWrap,
          start: 'top top',
          end: () => `bottom top`, // 任意：f-main-wrap の bottom が top を超えるまで
          onEnter: () => {
            // particles.classList.add('on');
            // movieTop.classList.add('sticky');
            // パララックスにより f-main-wrap が上にずれるので padding-bottom を video 高さ分付ける
            fMainWrap.style.paddingBottom = getVideoHeight() + 'px';
            // refresh して配置を安定させる
            ScrollTrigger.refresh();
          },
          onLeave: () => {
            particles.classList.add('on');
            movieTop.classList.add('sticky');
            // 終了時
          },
          onLeaveBack: () => {
            particles.classList.remove('on');
            movieTop.classList.remove('sticky');
            fMainWrap.style.paddingBottom = ''; // 元に戻す
            ScrollTrigger.refresh();
          },
        });

        // .last の上端がデバイス下端を上方向に通過したら movieTop に abs をつける
        // start: "top bottom" -> .last の top が viewport bottom に達した瞬間
        const absTrigger = ScrollTrigger.create({
          trigger: last,
          start: 'top bottom',
          // no explicit end; we use enter / leaveBack to toggle
          onEnter: () => {
            // last.top が viewport.bottom に入り上向きに通過した時（スクロールダウン）
            movieTop.classList.add('abs');
            // abs にしたときに sticky が残っていると位置が変になる可能性があるため sticky を外す
            // movieTop.classList.remove('sticky');
          },
          onLeaveBack: () => {
            // last.top が viewport.bottom を下方向に通過して戻ったとき（スクロールアップ）
            movieTop.classList.remove('abs');
          },
        });

        // リサイズ時の再計算（ビデオ高さ等）
        function handleResize() {
          // 更新：パララックスの end 長さを再設定するためにトリガーを更新
          parallaxTrigger.end = '+=' + getVideoHeight();
          // tween のターゲットの y を再計算
          parallaxTween.vars.y = () => -getVideoHeight();
          // padding-bottom の再計算（もし on 状態なら更新）
          if (particles.classList.contains('on')) {
            fMainWrap.style.paddingBottom = getVideoHeight() + 'px';
          }
          ScrollTrigger.refresh();
        }
        window.addEventListener('resize', () => {
          // debounce 風に少し待つ（500ms）
          clearTimeout(window._gsapResizeTimer);
          window._gsapResizeTimer = setTimeout(handleResize, 120);
        });

        // optional: video のメタデータロード後に最初のリフレッシュ
        if (videoEl) {
          // ビデオの読み込みが完了してからトリガーを正しく初期化したい場合
          videoEl.addEventListener('loadedmetadata', () => {
            handleResize();
          });
        }

        // 最終的な初期 refresh
        handleResize();

        // -- デバッグ表示（必要なければ削除してOK） --
        const dbg = document.createElement('div');
        dbg.className = 'debug-box';
        document.body.appendChild(dbg);
        function writeDebug() {
          dbg.innerHTML = `
          movieTop pos: ${Math.round(
            movieTop.getBoundingClientRect().top
          )}px<br>
          fMainWrap top: ${Math.round(
            fMainWrap.getBoundingClientRect().top
          )}px<br>
          last top: ${Math.round(last.getBoundingClientRect().top)}px<br>
          videoH: ${getVideoHeight()}px<br>
          classes: ${movieTop.className}
        `;
        }
        writeDebug();
        ScrollTrigger.addEventListener('refresh', writeDebug);
        window.addEventListener('scroll', writeDebug);
      });
    </script>
  </head>
  <body>
    <div class="f-container">
      <div class="f-main">
        <div class="movie-top">
          <!-- 動画を差し替えてください -->
          <video src="" playsinline muted autoplay loop></video>
        </div>

        <div class="f-main-wrap">
          <div class="contents">
            <h1>長いコンテンツ</h1>
            <p>
              ここに長いテキストやコンテンツが続きます。スクロールにより
              .movie-top の下端が画面下端を越えると .f-main-wrap
              がビデオ高さ分上に移動（パララックス）します。
            </p>
            <p>
              さらにスクロールを進めると .f-main-wrap の top が viewport top
              を越えた際に .particles-wrapper に
              <code>on</code> が付与され、.movie-top に
              <code>sticky</code>
              が付与され固定されます。パララックス分の余白（padding-bottom）は自動で付与されます。
            </p>
            <p>
              最後に .last の上端がデバイス下端を上向きに越えたタイミングで
              .movie-top に <code>abs</code> が付与され、.f-main
              下部に絶対配置されます（元の sticky は外れます）。
            </p>

            <!-- ダミーテキストを長めに配置 -->
            <div style="height: 1500px"></div>
          </div>
        </div>

        <!-- 雪など全画面の演出領域 -->
        <div class="particles-wrapper">
          <div style="text-align: center; font-size: 24px; opacity: 0.9">
            <div>❄️ Particles / Snow Area ❄️</div>
            <div style="font-size: 14px; margin-top: 8px">
              (.particles-wrapper に .on が付いたとき表示)
            </div>
          </div>
        </div>
      </div>
      <!-- .f-main -->

      <div class="last"></div>
    </div>
  </body>
</html>
